#!/usr/bin/env bash

set -euo pipefail

# Get the script directory
readonly script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"

# Get the Git repository root directory
readonly dir="$(git rev-parse --show-toplevel 2> /dev/null || echo "$script_dir")"

cd "$dir" || exit

usage() {
    cat << EOF
Usage: $(basename "$0") [-M|--major|-m|--minor|-p|--patch] [-d|--dry-run] [-h|--help]

Options:
  -M, --major     Increment major version
  -m, --minor     Increment minor version
  -p, --patch     Increment patch version (default if no option specified)
  -d, --dry-run   Dry run (don't make any changes)
  -h, --help      Display this help message

Example: $(basename "$0") -p
         Create a patch release

If no version increment option is specified, it will default to a patch increment.
EOF
}

semver_increment() {
    local -a parts
    IFS='.' read -ra parts <<< "$1"

    if [ ${#parts[@]} -ne 3 ]; then
        echo "Semantic versions should have 3 components (for example: 1.2.3)" >&2
        return 1
    fi

    case $2 in
        major)
            ((parts[0]++))
            parts[1]=0
            parts[2]=0
            ;;
        minor)
            ((parts[1]++))
            parts[2]=0
            ;;
        patch) ((parts[2]++)) ;;
        *)
            echo "Invalid increment type. Use major, minor, or patch." >&2
            return 1
            ;;
    esac

    echo "${parts[0]}.${parts[1]}.${parts[2]}"
}

get_current_version() {
    # Get the latest tag, fallback to 0.0.0
    local latest_tag
    latest_tag=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")

    # Ensure it's a valid 3-part version
    if [[ ! "$latest_tag" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        latest_tag="0.0.0"
    fi

    echo "$latest_tag"
}

update_version_file() {
    local new_version=$1

    # Create/update release.txt with version
    echo "v${new_version}" > release.txt

    echo "Updated release.txt to v${new_version}"
}

perform_release() {
    local new_version=$1

    if [ "$(git status --porcelain)" ]; then
        echo "Error: The git working directory is dirty (has uncommitted changes)."
        echo "Please commit or stash your changes and run the script again to release."
        exit 1
    fi

    # Update version file
    update_version_file "$new_version"

    # Commit version update
    git add release.txt
    git commit -m "ðŸ”– Release v${new_version}"

    # Create annotated tag
    git tag -a "v${new_version}" -m "Release v${new_version}"

    # Push commit and tag atomically
    git push --atomic origin HEAD "v${new_version}"

    echo -e "\n"
    echo "âœ… Released v${new_version}"
    echo "ðŸš€ GitHub Actions will now update the Homebrew formula automatically"
}

main() {
    local semver_type="patch"
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            -M | --major) semver_type="major" ;;
            -m | --minor) semver_type="minor" ;;
            -p | --patch) semver_type="patch" ;;
            -d | --dry-run) dry_run=true ;;
            -h | --help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                exit 1
                ;;
        esac
        shift
    done

    local current_version
    current_version=$(get_current_version)

    local new_version
    new_version=$(semver_increment "${current_version}" "${semver_type}")

    echo -e "\nRelease"
    echo " - this will be a ${semver_type} increment"
    echo " - the current version is v${current_version}"
    echo " - the new version will be v${new_version}"

    if $dry_run; then
        echo -e "\nDRY RUN: No changes will be made."
    else
        echo -e "\nThis will:"
        echo " 1. Update version in release.txt"
        echo " 2. Create a new commit"
        echo " 3. Create git tag v${new_version}"
        echo -e " 4. Push changes and trigger GitHub release automation\n"

        echo -n "Proceed? [Y/n] "
        read -r perform_update
        if [[ $perform_update =~ ^[Nn]$ ]]; then
            echo -e "\nABORTED"
        else
            perform_release "$new_version"
        fi
    fi
}

main "$@"
